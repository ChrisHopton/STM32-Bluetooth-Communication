{"ast":null,"code":"/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Nodes} Nodes\r\n * @typedef {import('hast').Parents} Parents\r\n *\r\n * @typedef {import('property-information').Schema} Schema\r\n *\r\n * @typedef {import('./components.js').Components} Components\r\n */\n\n/**\r\n * @typedef {JSX.Element | string | null | undefined} Child\r\n *   Child.\r\n *\r\n * @callback Create\r\n *   Create something in development or production.\r\n * @param {Nodes} node\r\n *   hast node.\r\n * @param {unknown} type\r\n *   Fragment symbol or tag name.\r\n * @param {Props} props\r\n *   Properties and children.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {JSX.Element}\r\n *   Result.\r\n *\r\n * @typedef {'html' | 'react'} ElementAttributeNameCase\r\n *   Casing to use for attribute names.\r\n *\r\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\r\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\r\n *\r\n * @typedef {[string, Value]} Field\r\n *   Property field.\r\n *\r\n * @typedef {unknown} Fragment\r\n *   Represent the children, typically a symbol.\r\n *\r\n * @callback Jsx\r\n *   Create a production element.\r\n * @param {unknown} type\r\n *   Element type: `Fragment` symbol, tag name (`string`), component.\r\n * @param {Props} props\r\n *   Element props, `children`, and maybe `node`.\r\n * @param {string | undefined} [key]\r\n *   Dynamicly generated key to use.\r\n * @returns {JSX.Element}\r\n *   An element from your framework.\r\n *\r\n * @callback JsxDev\r\n *   Create a development element.\r\n * @param {unknown} type\r\n *   Element type: `Fragment` symbol, tag name (`string`), component.\r\n * @param {Props} props\r\n *   Element props, `children`, and maybe `node`.\r\n * @param {string | undefined} key\r\n *   Dynamicly generated key to use.\r\n * @param {boolean} isStaticChildren\r\n *   Whether two or more children are passed (in an array), which is whether\r\n *   `jsxs` or `jsx` would be used.\r\n * @param {Source} source\r\n *   Info about source.\r\n * @param {undefined} self\r\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\r\n * @returns {JSX.Element}\r\n *   An element from your framework.\r\n *\r\n * @typedef {{children?: Array<Child> | Child, node?: Element | undefined, [prop: string]: Array<Child> | Child | Element | Value | undefined}} Props\r\n *   Properties and children.\r\n *\r\n * @typedef RegularFields\r\n *   Configuration.\r\n * @property {Partial<Components> | null | undefined} [components]\r\n *   Components to use (optional).\r\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\r\n *   Specify casing to use for attribute names (default: `'react'`).\r\n * @property {string | null | undefined} [filePath]\r\n *   File path to the original source file (optional).\r\n *\r\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\r\n *   `development: true`.\r\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\r\n *   Ignore invalid CSS in `style` props (default: `false`);\r\n *   the default behavior is to throw an error.\r\n * @property {boolean | null | undefined} [passKeys=true]\r\n *   Generate keys to optimize frameworks that support them (default: `true`).\r\n *\r\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\r\n * @property {boolean | null | undefined} [passNode=false]\r\n *   Pass the hast element node to components (default: `false`).\r\n * @property {Space | null | undefined} [space='html']\r\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\r\n *\r\n *   When an `<svg>` element is found in the HTML space, this package already\r\n *   automatically switches to and from the SVG space when entering and exiting\r\n *   it.\r\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\r\n *   Specify casing to use for property names in `style` objects (default:\r\n *   `'dom'`).\r\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\r\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\r\n *   (default: `true`).\r\n *\r\n * @typedef RuntimeDevelopment\r\n *   Runtime fields when development is on.\r\n * @property {Fragment} Fragment\r\n *   Fragment.\r\n * @property {true} development\r\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\r\n * @property {Jsx | null | undefined} [jsx]\r\n *   Dynamic JSX (optional).\r\n * @property {JsxDev} jsxDEV\r\n *   Development JSX.\r\n * @property {Jsx | null | undefined} [jsxs]\r\n *   Static JSX (optional).\r\n *\r\n * @typedef RuntimeProduction\r\n *   Runtime fields when development is off.\r\n * @property {Fragment} Fragment\r\n *   Fragment.\r\n * @property {false | null | undefined} [development]\r\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\r\n * @property {Jsx} jsx\r\n *   Dynamic JSX.\r\n * @property {JsxDev | null | undefined} [jsxDEV]\r\n *   Development JSX (optional).\r\n * @property {Jsx} jsxs\r\n *   Static JSX.\r\n *\r\n * @typedef RuntimeUnknown\r\n *   Runtime fields when development might be on or off.\r\n * @property {Fragment} Fragment\r\n *   Fragment.\r\n * @property {boolean} development\r\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\r\n * @property {Jsx | null | undefined} [jsx]\r\n *   Dynamic JSX (optional).\r\n * @property {JsxDev | null | undefined} [jsxDEV]\r\n *   Development JSX (optional).\r\n * @property {Jsx | null | undefined} [jsxs]\r\n *   Static JSX (optional).\r\n *\r\n * @typedef Source\r\n *   Info about source.\r\n * @property {number | undefined} columnNumber\r\n *   Column where thing starts (0-indexed).\r\n * @property {string | undefined} fileName\r\n *   Name of source file.\r\n * @property {number | undefined} lineNumber\r\n *   Line where thing starts (1-indexed).\r\n *\r\n * @typedef {'html' | 'svg'} Space\r\n *   Namespace.\r\n *\r\n *   > ðŸ‘‰ **Note**: hast is not XML.\r\n *   > It supports SVG as embedded in HTML.\r\n *   > It does not support the features available in XML.\r\n *   > Passing SVG might break but fragments of modern SVG should be fine.\r\n *   > Use `xast` if you need to support SVG as XML.\r\n *\r\n * @typedef State\r\n *   Info passed around.\r\n * @property {unknown} Fragment\r\n *   Fragment symbol.\r\n * @property {Array<Parents>} ancestors\r\n *   Stack of parents.\r\n * @property {Partial<Components>} components\r\n *   Components to swap.\r\n * @property {Create} create\r\n *   Create something in development or production.\r\n * @property {ElementAttributeNameCase} elementAttributeNameCase\r\n *   Casing to use for attribute names.\r\n * @property {string | undefined} filePath\r\n *   File path.\r\n * @property {boolean} ignoreInvalidStyle\r\n *   Ignore invalid CSS in `style` props.\r\n * @property {boolean} passKeys\r\n *   Generate keys to optimize frameworks that support them.\r\n * @property {boolean} passNode\r\n *   Pass `node` to components.\r\n * @property {Schema} schema\r\n *   Current schema.\r\n * @property {StylePropertyNameCase} stylePropertyNameCase\r\n *   Casing to use for property names in `style` objects.\r\n * @property {boolean} tableCellAlignToStyle\r\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\r\n *\r\n * @typedef {Record<string, string>} Style\r\n *   Style map.\r\n *\r\n * @typedef {'css' | 'dom'} StylePropertyNameCase\r\n *   Casing to use for property names in `style` objects.\r\n *\r\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\r\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\r\n *\r\n * @typedef {Style | boolean | number | string} Value\r\n *   Primitive property value and `Style` map.\r\n */\n\n/**\r\n * @typedef {RuntimeDevelopment & RegularFields} Development\r\n *   Configuration (development).\r\n * @typedef {Development | Production | Unknown} Options\r\n *   Configuration.\r\n * @typedef {RegularFields & RuntimeProduction} Production\r\n *   Configuration (production).\r\n * @typedef {RegularFields & RuntimeUnknown} Unknown\r\n *   Configuration (production or development).\r\n */\n\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { whitespace } from 'hast-util-whitespace';\nimport { find, hastToReact, html, svg } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport styleToObject from 'style-to-object';\nimport { pointStart } from 'unist-util-position';\nimport { VFileMessage } from 'vfile-message';\nconst own = {}.hasOwnProperty;\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map();\nconst cap = /[A-Z]/g;\nconst dashSomething = /-([a-z])/g;\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr']);\nconst tableCellElement = new Set(['td', 'th']);\n\n/**\r\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\r\n * with an automatic JSX runtime.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to transform.\r\n * @param {Options} options\r\n *   Configuration (required).\r\n * @returns {JSX.Element}\r\n *   JSX element.\r\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options');\n  }\n  const filePath = options.filePath || undefined;\n  /** @type {Create} */\n  let create;\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError('Expected `jsxDEV` in options when `development: true`');\n    }\n    create = developmentCreate(filePath, options.jsxDEV);\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options');\n    }\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options');\n    }\n    create = productionCreate(filePath, options.jsx, options.jsxs);\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  };\n  const result = one(state, tree, undefined);\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result;\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(tree, state.Fragment, {\n    children: result || undefined\n  }, undefined);\n}\n\n/**\r\n * Transform a node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Nodes} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction one(state, node, key) {\n  if (node.type === 'element' || node.type === 'root') {\n    const parentSchema = state.schema;\n    let schema = parentSchema;\n    if (node.type === 'element' && node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n      schema = svg;\n      state.schema = schema;\n    }\n    state.ancestors.push(node);\n    let children = createChildren(state, node);\n    const props = createProperties(state, state.ancestors);\n    let type = state.Fragment;\n    state.ancestors.pop();\n    if (node.type === 'element') {\n      if (children && tableElements.has(node.tagName)) {\n        children = children.filter(function (child) {\n          return typeof child === 'string' ? !whitespace(child) : true;\n        });\n      }\n      if (own.call(state.components, node.tagName)) {\n        const key = /** @type {keyof JSX.IntrinsicElements} */node.tagName;\n        type = state.components[key];\n\n        // If this is swapped out for a component:\n        if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n          props.node = node;\n        }\n      } else {\n        type = node.tagName;\n      }\n    }\n    if (children.length > 0) {\n      const value = children.length > 1 ? children : children[0];\n      if (value) {\n        props.children = value;\n      }\n    }\n\n    // Restore parent schema.\n    state.schema = parentSchema;\n    return state.create(node, type, props, key);\n  }\n  if (node.type === 'text') {\n    return node.value;\n  }\n}\n\n/**\r\n * @param {string | undefined} _\r\n *   Path to file.\r\n * @param {Jsx} jsx\r\n *   Dynamic.\r\n * @param {Jsx} jsxs\r\n *   Static.\r\n * @returns {Create}\r\n *   Create a production element.\r\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create;\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children);\n    const fn = isStaticChildren ? jsxs : jsx;\n    return key ? fn(type, props, key) : fn(type, props);\n  }\n}\n\n/**\r\n * @param {string | undefined} filePath\r\n *   Path to file.\r\n * @param {JsxDev} jsxDEV\r\n *   Development.\r\n * @returns {Create}\r\n *   Create a development element.\r\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create;\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children);\n    const point = pointStart(node);\n    return jsxDEV(type, props, key, isStaticChildren, {\n      columnNumber: point ? point.column - 1 : undefined,\n      fileName: filePath,\n      lineNumber: point ? point.line : undefined\n    }, undefined);\n  }\n}\n\n/**\r\n * Create children.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Parents} node\r\n *   Current element.\r\n * @returns {Array<Child>}\r\n *   Children.\r\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = [];\n  let index = -1;\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByTagName = state.passKeys ? new Map() : emptyMap;\n  while (++index < node.children.length) {\n    const child = node.children[index];\n    /** @type {string | undefined} */\n    let key;\n    if (state.passKeys && child.type === 'element') {\n      const count = countsByTagName.get(child.tagName) || 0;\n      key = child.tagName + '-' + count;\n      countsByTagName.set(child.tagName, count + 1);\n    }\n    const result = one(state, child, key);\n    if (result !== undefined) children.push(result);\n  }\n  return children;\n}\n\n/**\r\n * Handle properties.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Array<Parents>} ancestors\r\n *   Stack of parents.\r\n * @returns {Props}\r\n *   Props for runtime.\r\n */\nfunction createProperties(state, ancestors) {\n  const node = ancestors[ancestors.length - 1];\n  /** @type {Props} */\n  const props = {};\n  /** @type {string} */\n  let prop;\n  if ('properties' in node && node.properties) {\n    /** @type {string | undefined} */\n    let alignValue;\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        const result = createProperty(state, ancestors, prop, node.properties[prop]);\n        if (result) {\n          const [key, value] = result;\n          if (state.tableCellAlignToStyle && key === 'align' && typeof value === 'string' && tableCellElement.has(node.tagName)) {\n            alignValue = value;\n          } else {\n            props[key] = value;\n          }\n        }\n      }\n    }\n    if (alignValue) {\n      // Assume style is an object.\n      const style = /** @type {Style} */props.style || (props.style = {});\n      style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] = alignValue;\n    }\n  }\n  return props;\n}\n\n/**\r\n * Handle a property.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Array<Parents>} ancestors\r\n *   Stack of parents.\r\n * @param {string} prop\r\n *   Key.\r\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\r\n *   hast property value.\r\n * @returns {Field | undefined}\r\n *   Field for runtime, optional.\r\n */\nfunction createProperty(state, ancestors, prop, value) {\n  const info = find(state.schema, prop);\n\n  // Ignore nullish and `NaN` values.\n  if (value === null || value === undefined || typeof value === 'number' && Number.isNaN(value)) {\n    return;\n  }\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject = typeof value === 'object' ? value : parseStyle(state, ancestors, String(value));\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject);\n    }\n    return ['style', styleObject];\n  }\n  return [state.elementAttributeNameCase === 'react' && info.space ? hastToReact[info.property] || info.property : info.attribute, value];\n}\n\n/**\r\n * Parse a CSS declaration to an object.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Array<Nodes>} ancestors\r\n *   Stack of nodes.\r\n * @param {string} value\r\n *   CSS declarations.\r\n * @returns {Style}\r\n *   Properties.\r\n * @throws\r\n *   Throws `VFileMessage` when CSS cannot be parsed.\r\n */\nfunction parseStyle(state, ancestors, value) {\n  /** @type {Style} */\n  const result = {};\n  try {\n    styleToObject(value, replacer);\n  } catch (error) {\n    if (!state.ignoreInvalidStyle) {\n      const cause = /** @type {Error} */error;\n      const message = new VFileMessage('Cannot parse `style` attribute', {\n        ancestors,\n        cause,\n        source: 'hast-util-to-jsx-runtime',\n        ruleId: 'style'\n      });\n      message.file = state.filePath || undefined;\n      message.url = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute';\n      throw message;\n    }\n  }\n  return result;\n\n  /**\r\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\r\n   * property.\r\n   *\r\n   * @param {string} name\r\n   *   Key.\r\n   * @param {string} value\r\n   *   Value\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\n  function replacer(name, value) {\n    let key = name;\n    if (key.slice(0, 2) !== '--') {\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4);\n      key = key.replace(dashSomething, toCamel);\n    }\n    result[key] = value;\n  }\n}\n\n/**\r\n * Transform a DOM casing style object to a CSS casing style object.\r\n *\r\n * @param {Style} domCasing\r\n * @returns {Style}\r\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {};\n  /** @type {string} */\n  let from;\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n    }\n  }\n  return cssCasing;\n}\n\n/**\r\n * Transform a DOM casing style field to a CSS casing style field.\r\n *\r\n * @param {string} from\r\n * @returns {string}\r\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash);\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to;\n  return to;\n}\n\n/**\r\n * Make `$1` capitalized.\r\n *\r\n * @param {string} _\r\n *   Whatever.\r\n * @param {string} $1\r\n *   Single ASCII alphabetical.\r\n * @returns {string}\r\n *   Capitalized `$1`.\r\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase();\n}\n\n/**\r\n * Make `$0` dash cased.\r\n *\r\n * @param {string} $0\r\n *   Capitalized ASCII leter.\r\n * @returns {string}\r\n *   Dash and lower letter.\r\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase();\n}","map":{"version":3,"names":["stringify","commas","whitespace","find","hastToReact","html","svg","spaces","styleToObject","pointStart","VFileMessage","own","hasOwnProperty","emptyMap","Map","cap","dashSomething","tableElements","Set","tableCellElement","toJsxRuntime","tree","options","Fragment","undefined","TypeError","filePath","create","development","jsxDEV","developmentCreate","jsx","jsxs","productionCreate","state","ancestors","components","elementAttributeNameCase","ignoreInvalidStyle","passKeys","passNode","schema","space","stylePropertyNameCase","tableCellAlignToStyle","result","one","children","node","key","type","parentSchema","tagName","toLowerCase","push","createChildren","props","createProperties","pop","has","filter","child","call","length","value","_","isStaticChildren","Array","isArray","fn","point","columnNumber","column","fileName","lineNumber","line","index","countsByTagName","count","get","set","prop","properties","alignValue","createProperty","style","info","Number","isNaN","commaSeparated","property","styleObject","parseStyle","String","transformStylesToCssCasing","attribute","replacer","error","cause","message","source","ruleId","file","url","name","slice","replace","toCamel","domCasing","cssCasing","from","transformStyleToCssCasing","to","toDash","$1","toUpperCase","$0"],"sources":["C:/Users/mathe/Dropbox/PC/Documents/GitHub/STM32-Bluetooth-Communication/my-app/node_modules/hast-util-to-jsx-runtime/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Nodes} Nodes\r\n * @typedef {import('hast').Parents} Parents\r\n *\r\n * @typedef {import('property-information').Schema} Schema\r\n *\r\n * @typedef {import('./components.js').Components} Components\r\n */\r\n\r\n/**\r\n * @typedef {JSX.Element | string | null | undefined} Child\r\n *   Child.\r\n *\r\n * @callback Create\r\n *   Create something in development or production.\r\n * @param {Nodes} node\r\n *   hast node.\r\n * @param {unknown} type\r\n *   Fragment symbol or tag name.\r\n * @param {Props} props\r\n *   Properties and children.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {JSX.Element}\r\n *   Result.\r\n *\r\n * @typedef {'html' | 'react'} ElementAttributeNameCase\r\n *   Casing to use for attribute names.\r\n *\r\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\r\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\r\n *\r\n * @typedef {[string, Value]} Field\r\n *   Property field.\r\n *\r\n * @typedef {unknown} Fragment\r\n *   Represent the children, typically a symbol.\r\n *\r\n * @callback Jsx\r\n *   Create a production element.\r\n * @param {unknown} type\r\n *   Element type: `Fragment` symbol, tag name (`string`), component.\r\n * @param {Props} props\r\n *   Element props, `children`, and maybe `node`.\r\n * @param {string | undefined} [key]\r\n *   Dynamicly generated key to use.\r\n * @returns {JSX.Element}\r\n *   An element from your framework.\r\n *\r\n * @callback JsxDev\r\n *   Create a development element.\r\n * @param {unknown} type\r\n *   Element type: `Fragment` symbol, tag name (`string`), component.\r\n * @param {Props} props\r\n *   Element props, `children`, and maybe `node`.\r\n * @param {string | undefined} key\r\n *   Dynamicly generated key to use.\r\n * @param {boolean} isStaticChildren\r\n *   Whether two or more children are passed (in an array), which is whether\r\n *   `jsxs` or `jsx` would be used.\r\n * @param {Source} source\r\n *   Info about source.\r\n * @param {undefined} self\r\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\r\n * @returns {JSX.Element}\r\n *   An element from your framework.\r\n *\r\n * @typedef {{children?: Array<Child> | Child, node?: Element | undefined, [prop: string]: Array<Child> | Child | Element | Value | undefined}} Props\r\n *   Properties and children.\r\n *\r\n * @typedef RegularFields\r\n *   Configuration.\r\n * @property {Partial<Components> | null | undefined} [components]\r\n *   Components to use (optional).\r\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\r\n *   Specify casing to use for attribute names (default: `'react'`).\r\n * @property {string | null | undefined} [filePath]\r\n *   File path to the original source file (optional).\r\n *\r\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\r\n *   `development: true`.\r\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\r\n *   Ignore invalid CSS in `style` props (default: `false`);\r\n *   the default behavior is to throw an error.\r\n * @property {boolean | null | undefined} [passKeys=true]\r\n *   Generate keys to optimize frameworks that support them (default: `true`).\r\n *\r\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\r\n * @property {boolean | null | undefined} [passNode=false]\r\n *   Pass the hast element node to components (default: `false`).\r\n * @property {Space | null | undefined} [space='html']\r\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\r\n *\r\n *   When an `<svg>` element is found in the HTML space, this package already\r\n *   automatically switches to and from the SVG space when entering and exiting\r\n *   it.\r\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\r\n *   Specify casing to use for property names in `style` objects (default:\r\n *   `'dom'`).\r\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\r\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\r\n *   (default: `true`).\r\n *\r\n * @typedef RuntimeDevelopment\r\n *   Runtime fields when development is on.\r\n * @property {Fragment} Fragment\r\n *   Fragment.\r\n * @property {true} development\r\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\r\n * @property {Jsx | null | undefined} [jsx]\r\n *   Dynamic JSX (optional).\r\n * @property {JsxDev} jsxDEV\r\n *   Development JSX.\r\n * @property {Jsx | null | undefined} [jsxs]\r\n *   Static JSX (optional).\r\n *\r\n * @typedef RuntimeProduction\r\n *   Runtime fields when development is off.\r\n * @property {Fragment} Fragment\r\n *   Fragment.\r\n * @property {false | null | undefined} [development]\r\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\r\n * @property {Jsx} jsx\r\n *   Dynamic JSX.\r\n * @property {JsxDev | null | undefined} [jsxDEV]\r\n *   Development JSX (optional).\r\n * @property {Jsx} jsxs\r\n *   Static JSX.\r\n *\r\n * @typedef RuntimeUnknown\r\n *   Runtime fields when development might be on or off.\r\n * @property {Fragment} Fragment\r\n *   Fragment.\r\n * @property {boolean} development\r\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\r\n * @property {Jsx | null | undefined} [jsx]\r\n *   Dynamic JSX (optional).\r\n * @property {JsxDev | null | undefined} [jsxDEV]\r\n *   Development JSX (optional).\r\n * @property {Jsx | null | undefined} [jsxs]\r\n *   Static JSX (optional).\r\n *\r\n * @typedef Source\r\n *   Info about source.\r\n * @property {number | undefined} columnNumber\r\n *   Column where thing starts (0-indexed).\r\n * @property {string | undefined} fileName\r\n *   Name of source file.\r\n * @property {number | undefined} lineNumber\r\n *   Line where thing starts (1-indexed).\r\n *\r\n * @typedef {'html' | 'svg'} Space\r\n *   Namespace.\r\n *\r\n *   > ðŸ‘‰ **Note**: hast is not XML.\r\n *   > It supports SVG as embedded in HTML.\r\n *   > It does not support the features available in XML.\r\n *   > Passing SVG might break but fragments of modern SVG should be fine.\r\n *   > Use `xast` if you need to support SVG as XML.\r\n *\r\n * @typedef State\r\n *   Info passed around.\r\n * @property {unknown} Fragment\r\n *   Fragment symbol.\r\n * @property {Array<Parents>} ancestors\r\n *   Stack of parents.\r\n * @property {Partial<Components>} components\r\n *   Components to swap.\r\n * @property {Create} create\r\n *   Create something in development or production.\r\n * @property {ElementAttributeNameCase} elementAttributeNameCase\r\n *   Casing to use for attribute names.\r\n * @property {string | undefined} filePath\r\n *   File path.\r\n * @property {boolean} ignoreInvalidStyle\r\n *   Ignore invalid CSS in `style` props.\r\n * @property {boolean} passKeys\r\n *   Generate keys to optimize frameworks that support them.\r\n * @property {boolean} passNode\r\n *   Pass `node` to components.\r\n * @property {Schema} schema\r\n *   Current schema.\r\n * @property {StylePropertyNameCase} stylePropertyNameCase\r\n *   Casing to use for property names in `style` objects.\r\n * @property {boolean} tableCellAlignToStyle\r\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\r\n *\r\n * @typedef {Record<string, string>} Style\r\n *   Style map.\r\n *\r\n * @typedef {'css' | 'dom'} StylePropertyNameCase\r\n *   Casing to use for property names in `style` objects.\r\n *\r\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\r\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\r\n *\r\n * @typedef {Style | boolean | number | string} Value\r\n *   Primitive property value and `Style` map.\r\n */\r\n\r\n/**\r\n * @typedef {RuntimeDevelopment & RegularFields} Development\r\n *   Configuration (development).\r\n * @typedef {Development | Production | Unknown} Options\r\n *   Configuration.\r\n * @typedef {RegularFields & RuntimeProduction} Production\r\n *   Configuration (production).\r\n * @typedef {RegularFields & RuntimeUnknown} Unknown\r\n *   Configuration (production or development).\r\n */\r\n\r\nimport {stringify as commas} from 'comma-separated-tokens'\r\nimport {whitespace} from 'hast-util-whitespace'\r\nimport {find, hastToReact, html, svg} from 'property-information'\r\nimport {stringify as spaces} from 'space-separated-tokens'\r\nimport styleToObject from 'style-to-object'\r\nimport {pointStart} from 'unist-util-position'\r\nimport {VFileMessage} from 'vfile-message'\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/** @type {Map<string, number>} */\r\nconst emptyMap = new Map()\r\n\r\nconst cap = /[A-Z]/g\r\nconst dashSomething = /-([a-z])/g\r\n\r\n// `react-dom` triggers a warning for *any* white space in tables.\r\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\r\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\r\n// that.\r\n\r\n// See: <https://github.com/facebook/react/pull/7081>.\r\n// See: <https://github.com/facebook/react/pull/7515>.\r\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\r\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\r\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\r\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\r\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\r\n\r\nconst tableCellElement = new Set(['td', 'th'])\r\n\r\n/**\r\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\r\n * with an automatic JSX runtime.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to transform.\r\n * @param {Options} options\r\n *   Configuration (required).\r\n * @returns {JSX.Element}\r\n *   JSX element.\r\n */\r\n\r\nexport function toJsxRuntime(tree, options) {\r\n  if (!options || options.Fragment === undefined) {\r\n    throw new TypeError('Expected `Fragment` in options')\r\n  }\r\n\r\n  const filePath = options.filePath || undefined\r\n  /** @type {Create} */\r\n  let create\r\n\r\n  if (options.development) {\r\n    if (typeof options.jsxDEV !== 'function') {\r\n      throw new TypeError(\r\n        'Expected `jsxDEV` in options when `development: true`'\r\n      )\r\n    }\r\n\r\n    create = developmentCreate(filePath, options.jsxDEV)\r\n  } else {\r\n    if (typeof options.jsx !== 'function') {\r\n      throw new TypeError('Expected `jsx` in production options')\r\n    }\r\n\r\n    if (typeof options.jsxs !== 'function') {\r\n      throw new TypeError('Expected `jsxs` in production options')\r\n    }\r\n\r\n    create = productionCreate(filePath, options.jsx, options.jsxs)\r\n  }\r\n\r\n  /** @type {State} */\r\n  const state = {\r\n    Fragment: options.Fragment,\r\n    ancestors: [],\r\n    components: options.components || {},\r\n    create,\r\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\r\n    filePath,\r\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\r\n    passKeys: options.passKeys !== false,\r\n    passNode: options.passNode || false,\r\n    schema: options.space === 'svg' ? svg : html,\r\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\r\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\r\n  }\r\n\r\n  const result = one(state, tree, undefined)\r\n\r\n  // JSX element.\r\n  if (result && typeof result !== 'string') {\r\n    return result\r\n  }\r\n\r\n  // Text node or something that turned into nothing.\r\n  return state.create(\r\n    tree,\r\n    state.Fragment,\r\n    {children: result || undefined},\r\n    undefined\r\n  )\r\n}\r\n\r\n/**\r\n * Transform a node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Nodes} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction one(state, node, key) {\r\n  if (node.type === 'element' || node.type === 'root') {\r\n    const parentSchema = state.schema\r\n    let schema = parentSchema\r\n\r\n    if (\r\n      node.type === 'element' &&\r\n      node.tagName.toLowerCase() === 'svg' &&\r\n      parentSchema.space === 'html'\r\n    ) {\r\n      schema = svg\r\n      state.schema = schema\r\n    }\r\n\r\n    state.ancestors.push(node)\r\n\r\n    let children = createChildren(state, node)\r\n    const props = createProperties(state, state.ancestors)\r\n    let type = state.Fragment\r\n\r\n    state.ancestors.pop()\r\n\r\n    if (node.type === 'element') {\r\n      if (children && tableElements.has(node.tagName)) {\r\n        children = children.filter(function (child) {\r\n          return typeof child === 'string' ? !whitespace(child) : true\r\n        })\r\n      }\r\n\r\n      if (own.call(state.components, node.tagName)) {\r\n        const key = /** @type {keyof JSX.IntrinsicElements} */ (node.tagName)\r\n        type = state.components[key]\r\n\r\n        // If this is swapped out for a component:\r\n        if (\r\n          typeof type !== 'string' &&\r\n          type !== state.Fragment &&\r\n          state.passNode\r\n        ) {\r\n          props.node = node\r\n        }\r\n      } else {\r\n        type = node.tagName\r\n      }\r\n    }\r\n\r\n    if (children.length > 0) {\r\n      const value = children.length > 1 ? children : children[0]\r\n\r\n      if (value) {\r\n        props.children = value\r\n      }\r\n    }\r\n\r\n    // Restore parent schema.\r\n    state.schema = parentSchema\r\n\r\n    return state.create(node, type, props, key)\r\n  }\r\n\r\n  if (node.type === 'text') {\r\n    return node.value\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string | undefined} _\r\n *   Path to file.\r\n * @param {Jsx} jsx\r\n *   Dynamic.\r\n * @param {Jsx} jsxs\r\n *   Static.\r\n * @returns {Create}\r\n *   Create a production element.\r\n */\r\nfunction productionCreate(_, jsx, jsxs) {\r\n  return create\r\n  /** @type {Create} */\r\n  function create(_, type, props, key) {\r\n    // Only an array when there are 2 or more children.\r\n    const isStaticChildren = Array.isArray(props.children)\r\n    const fn = isStaticChildren ? jsxs : jsx\r\n    return key ? fn(type, props, key) : fn(type, props)\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string | undefined} filePath\r\n *   Path to file.\r\n * @param {JsxDev} jsxDEV\r\n *   Development.\r\n * @returns {Create}\r\n *   Create a development element.\r\n */\r\nfunction developmentCreate(filePath, jsxDEV) {\r\n  return create\r\n  /** @type {Create} */\r\n  function create(node, type, props, key) {\r\n    // Only an array when there are 2 or more children.\r\n    const isStaticChildren = Array.isArray(props.children)\r\n    const point = pointStart(node)\r\n    return jsxDEV(\r\n      type,\r\n      props,\r\n      key,\r\n      isStaticChildren,\r\n      {\r\n        columnNumber: point ? point.column - 1 : undefined,\r\n        fileName: filePath,\r\n        lineNumber: point ? point.line : undefined\r\n      },\r\n      undefined\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Create children.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Parents} node\r\n *   Current element.\r\n * @returns {Array<Child>}\r\n *   Children.\r\n */\r\nfunction createChildren(state, node) {\r\n  /** @type {Array<Child>} */\r\n  const children = []\r\n  let index = -1\r\n  /** @type {Map<string, number>} */\r\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\r\n  /* c8 ignore next */\r\n  const countsByTagName = state.passKeys ? new Map() : emptyMap\r\n\r\n  while (++index < node.children.length) {\r\n    const child = node.children[index]\r\n    /** @type {string | undefined} */\r\n    let key\r\n\r\n    if (state.passKeys && child.type === 'element') {\r\n      const count = countsByTagName.get(child.tagName) || 0\r\n      key = child.tagName + '-' + count\r\n      countsByTagName.set(child.tagName, count + 1)\r\n    }\r\n\r\n    const result = one(state, child, key)\r\n    if (result !== undefined) children.push(result)\r\n  }\r\n\r\n  return children\r\n}\r\n\r\n/**\r\n * Handle properties.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Array<Parents>} ancestors\r\n *   Stack of parents.\r\n * @returns {Props}\r\n *   Props for runtime.\r\n */\r\nfunction createProperties(state, ancestors) {\r\n  const node = ancestors[ancestors.length - 1]\r\n  /** @type {Props} */\r\n  const props = {}\r\n  /** @type {string} */\r\n  let prop\r\n\r\n  if ('properties' in node && node.properties) {\r\n    /** @type {string | undefined} */\r\n    let alignValue\r\n\r\n    for (prop in node.properties) {\r\n      if (prop !== 'children' && own.call(node.properties, prop)) {\r\n        const result = createProperty(\r\n          state,\r\n          ancestors,\r\n          prop,\r\n          node.properties[prop]\r\n        )\r\n\r\n        if (result) {\r\n          const [key, value] = result\r\n\r\n          if (\r\n            state.tableCellAlignToStyle &&\r\n            key === 'align' &&\r\n            typeof value === 'string' &&\r\n            tableCellElement.has(node.tagName)\r\n          ) {\r\n            alignValue = value\r\n          } else {\r\n            props[key] = value\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (alignValue) {\r\n      // Assume style is an object.\r\n      const style = /** @type {Style} */ (props.style || (props.style = {}))\r\n      style[\r\n        state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'\r\n      ] = alignValue\r\n    }\r\n  }\r\n\r\n  return props\r\n}\r\n\r\n/**\r\n * Handle a property.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Array<Parents>} ancestors\r\n *   Stack of parents.\r\n * @param {string} prop\r\n *   Key.\r\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\r\n *   hast property value.\r\n * @returns {Field | undefined}\r\n *   Field for runtime, optional.\r\n */\r\nfunction createProperty(state, ancestors, prop, value) {\r\n  const info = find(state.schema, prop)\r\n\r\n  // Ignore nullish and `NaN` values.\r\n  if (\r\n    value === null ||\r\n    value === undefined ||\r\n    (typeof value === 'number' && Number.isNaN(value))\r\n  ) {\r\n    return\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    // Accept `array`.\r\n    // Most props are space-separated.\r\n    value = info.commaSeparated ? commas(value) : spaces(value)\r\n  }\r\n\r\n  // React only accepts `style` as object.\r\n  if (info.property === 'style') {\r\n    let styleObject =\r\n      typeof value === 'object'\r\n        ? value\r\n        : parseStyle(state, ancestors, String(value))\r\n\r\n    if (state.stylePropertyNameCase === 'css') {\r\n      styleObject = transformStylesToCssCasing(styleObject)\r\n    }\r\n\r\n    return ['style', styleObject]\r\n  }\r\n\r\n  return [\r\n    state.elementAttributeNameCase === 'react' && info.space\r\n      ? hastToReact[info.property] || info.property\r\n      : info.attribute,\r\n    value\r\n  ]\r\n}\r\n\r\n/**\r\n * Parse a CSS declaration to an object.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Array<Nodes>} ancestors\r\n *   Stack of nodes.\r\n * @param {string} value\r\n *   CSS declarations.\r\n * @returns {Style}\r\n *   Properties.\r\n * @throws\r\n *   Throws `VFileMessage` when CSS cannot be parsed.\r\n */\r\nfunction parseStyle(state, ancestors, value) {\r\n  /** @type {Style} */\r\n  const result = {}\r\n\r\n  try {\r\n    styleToObject(value, replacer)\r\n  } catch (error) {\r\n    if (!state.ignoreInvalidStyle) {\r\n      const cause = /** @type {Error} */ (error)\r\n      const message = new VFileMessage('Cannot parse `style` attribute', {\r\n        ancestors,\r\n        cause,\r\n        source: 'hast-util-to-jsx-runtime',\r\n        ruleId: 'style'\r\n      })\r\n      message.file = state.filePath || undefined\r\n      message.url =\r\n        'https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute'\r\n\r\n      throw message\r\n    }\r\n  }\r\n\r\n  return result\r\n\r\n  /**\r\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\r\n   * property.\r\n   *\r\n   * @param {string} name\r\n   *   Key.\r\n   * @param {string} value\r\n   *   Value\r\n   * @returns {undefined}\r\n   *   Nothing.\r\n   */\r\n  function replacer(name, value) {\r\n    let key = name\r\n\r\n    if (key.slice(0, 2) !== '--') {\r\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\r\n      key = key.replace(dashSomething, toCamel)\r\n    }\r\n\r\n    result[key] = value\r\n  }\r\n}\r\n\r\n/**\r\n * Transform a DOM casing style object to a CSS casing style object.\r\n *\r\n * @param {Style} domCasing\r\n * @returns {Style}\r\n */\r\nfunction transformStylesToCssCasing(domCasing) {\r\n  /** @type {Style} */\r\n  const cssCasing = {}\r\n  /** @type {string} */\r\n  let from\r\n\r\n  for (from in domCasing) {\r\n    if (own.call(domCasing, from)) {\r\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\r\n    }\r\n  }\r\n\r\n  return cssCasing\r\n}\r\n\r\n/**\r\n * Transform a DOM casing style field to a CSS casing style field.\r\n *\r\n * @param {string} from\r\n * @returns {string}\r\n */\r\nfunction transformStyleToCssCasing(from) {\r\n  let to = from.replace(cap, toDash)\r\n  // Handle `ms-xxx` -> `-ms-xxx`.\r\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\r\n  return to\r\n}\r\n\r\n/**\r\n * Make `$1` capitalized.\r\n *\r\n * @param {string} _\r\n *   Whatever.\r\n * @param {string} $1\r\n *   Single ASCII alphabetical.\r\n * @returns {string}\r\n *   Capitalized `$1`.\r\n */\r\nfunction toCamel(_, $1) {\r\n  return $1.toUpperCase()\r\n}\r\n\r\n/**\r\n * Make `$0` dash cased.\r\n *\r\n * @param {string} $0\r\n *   Capitalized ASCII leter.\r\n * @returns {string}\r\n *   Dash and lower letter.\r\n */\r\nfunction toDash($0) {\r\n  return '-' + $0.toLowerCase()\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,SAAS,IAAIC,MAAM,QAAO,wBAAwB;AAC1D,SAAQC,UAAU,QAAO,sBAAsB;AAC/C,SAAQC,IAAI,EAAEC,WAAW,EAAEC,IAAI,EAAEC,GAAG,QAAO,sBAAsB;AACjE,SAAQN,SAAS,IAAIO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"},"metadata":{},"sourceType":"module","externalDependencies":[]}